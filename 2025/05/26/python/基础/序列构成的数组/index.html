<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>序列构成的数组 - ZCCT</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ZCCT"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ZCCT"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="[TOC] 序列类型Python 标准库用 C 实现了丰富的序列类型，列举如下。"><meta property="og:type" content="blog"><meta property="og:title" content="序列构成的数组"><meta property="og:url" content="https://zcct123.github.io/2025/05/26/python/%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/"><meta property="og:site_name" content="ZCCT"><meta property="og:description" content="[TOC] 序列类型Python 标准库用 C 实现了丰富的序列类型，列举如下。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zcct123.github.io/media/17472871721018/17472873401879.jpg"><meta property="og:image" content="https://zcct123.github.io/media/17472871721018/17472879798002.jpg"><meta property="og:image" content="https://zcct123.github.io/media/17472871721018/17472882090357.jpg"><meta property="og:image" content="https://zcct123.github.io/media/17472871721018/17472884867133.jpg"><meta property="og:image" content="https://zcct123.github.io/media/17472871721018/17472915708876.jpg"><meta property="og:image" content="https://zcct123.github.io/media/17472871721018/17472920144835.jpg"><meta property="og:image" content="https://zcct123.github.io/media/17472871721018/17472920373141.jpg"><meta property="og:image" content="https://zcct123.github.io/media/17472871721018/17473010830518.jpg"><meta property="og:image" content="https://zcct123.github.io/media/17472871721018/17482299298715.jpg"><meta property="article:published_time" content="2025-05-26T04:00:00.000Z"><meta property="article:modified_time" content="2025-05-26T08:21:10.184Z"><meta property="article:author" content="zcct"><meta property="article:tag" content="python基础"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://zcct123.github.io/media/17472871721018/17472873401879.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zcct123.github.io/2025/05/26/python/%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/"},"headline":"序列构成的数组","image":["https://zcct123.github.io/media/17472871721018/17472873401879.jpg","https://zcct123.github.io/media/17472871721018/17472879798002.jpg","https://zcct123.github.io/media/17472871721018/17472882090357.jpg","https://zcct123.github.io/media/17472871721018/17472884867133.jpg","https://zcct123.github.io/media/17472871721018/17472915708876.jpg","https://zcct123.github.io/media/17472871721018/17472920144835.jpg","https://zcct123.github.io/media/17472871721018/17472920373141.jpg","https://zcct123.github.io/media/17472871721018/17473010830518.jpg","https://zcct123.github.io/media/17472871721018/17482299298715.jpg"],"datePublished":"2025-05-26T04:00:00.000Z","dateModified":"2025-05-26T08:21:10.184Z","author":{"@type":"Person","name":"zcct"},"publisher":{"@type":"Organization","name":"ZCCT","logo":{"@type":"ImageObject","url":"https://zcct123.github.io/img/logo.svg"}},"description":"[TOC] 序列类型Python 标准库用 C 实现了丰富的序列类型，列举如下。"}</script><link rel="canonical" href="https://zcct123.github.io/2025/05/26/python/%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="ZCCT" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">档案</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://gitee.com/zclvct"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-26T04:00:00.000Z" title="2025/5/26 12:00:00">2025-05-26</time>发表</span><span class="level-item"><time dateTime="2025-05-26T08:21:10.184Z" title="2025/5/26 16:21:10">2025-05-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/python/">python</a></span><span class="level-item">1 小时读完 (大约6866个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">序列构成的数组</h1><div class="content"><p>[TOC]</p>
<h2 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h2><p><strong>Python 标准库用 C 实现了丰富的序列类型，列举如下</strong>。</p>
<span id="more"></span>

<ul>
<li>容器序列<br>　　list、tuple 和 collections.deque 这些序列能存放不同类型的数据。</li>
<li>扁平序列<br>　　str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不<br>是引用。换句话说，扁平序列其实是一段连续的内存空间。由此可见扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型。</p>
<p><strong>序列类型还能按照能否被修改来分类。</strong></p>
<ul>
<li>可变序列<br>　　list、bytearray、array.array、collections.deque 和 memoryview。</li>
<li>不可变序列<br>　　tuple、str 和 bytes。</li>
</ul>
<p><img src="/media/17472871721018/17472873401879.jpg"></p>
<h2 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h2><p>列表推导（List Comprehension）是 Python 中一种简洁且高效的创建列表的语法。它允许你在一行代码内通过对可迭代对象（如列表、元组、范围等）进行遍历、筛选和转换，从而生成新的列表。</p>
<p><img src="/media/17472871721018/17472879798002.jpg"></p>
<h3 id="列表推导同filter和map的比较"><a href="#列表推导同filter和map的比较" class="headerlink" title="列表推导同filter和map的比较"></a>列表推导同filter和map的比较</h3><p><img src="/media/17472871721018/17472882090357.jpg"></p>
<p>列表推导（List Comprehension）、<code>filter()</code> 和 <code>map()</code> 都可用于处理可迭代对象，它们的功能存在重叠，但语法和适用场景各有不同。下面对它们进行详细对比。</p>
<h4 id="1-列表推导"><a href="#1-列表推导" class="headerlink" title="1. 列表推导"></a><strong>1. 列表推导</strong></h4><ul>
<li><strong>语法</strong>：<code>[表达式 for 变量 in 可迭代对象 if 条件]</code></li>
<li><strong>作用</strong>：结合筛选和转换，生成新列表。</li>
<li><strong>示例</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选偶数并平方</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">result = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 输出: [4, 16]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-map-函数"><a href="#2-map-函数" class="headerlink" title="2. map() 函数"></a><strong>2. <code>map()</code> 函数</strong></h4><ul>
<li><strong>语法</strong>：<code>map(函数, 可迭代对象)</code></li>
<li><strong>作用</strong>：对每个元素应用函数，返回迭代器。</li>
<li><strong>示例</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, nums)</span><br><span class="line"><span class="comment"># 需用 list() 转换: [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-filter-函数"><a href="#3-filter-函数" class="headerlink" title="3. filter() 函数"></a><strong>3. <code>filter()</code> 函数</strong></h4><ul>
<li><strong>语法</strong>：<code>filter(判断函数, 可迭代对象)</code></li>
<li><strong>作用</strong>：筛选出满足条件的元素，返回迭代器。</li>
<li><strong>示例</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, nums)</span><br><span class="line"><span class="comment"># 需用 list() 转换: [2, 4]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="笛卡儿积"><a href="#笛卡儿积" class="headerlink" title="笛卡儿积"></a>笛卡儿积</h3><p><img src="/media/17472871721018/17472884867133.jpg"></p>
<h4 id="使用列表推导计算笛卡儿积"><a href="#使用列表推导计算笛卡儿积" class="headerlink" title="使用列表推导计算笛卡儿积"></a>使用列表推导计算笛卡儿积</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; colors = [&#x27;black&#x27;, &#x27;white&#x27;]</span><br><span class="line">&gt;&gt;&gt; sizes = [&#x27;S&#x27;, &#x27;M&#x27;, &#x27;L&#x27;]</span><br><span class="line">&gt;&gt;&gt; tshirts = [(color, size) for color in colors for size in sizes] </span><br><span class="line">&gt;&gt;&gt; tshirts</span><br><span class="line">[(&#x27;black&#x27;, &#x27;S&#x27;), (&#x27;black&#x27;, &#x27;M&#x27;), (&#x27;black&#x27;, &#x27;L&#x27;), (&#x27;white&#x27;, &#x27;S&#x27;),</span><br><span class="line"> (&#x27;white&#x27;, &#x27;M&#x27;), (&#x27;white&#x27;, &#x27;L&#x27;)]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; for color in colors: </span><br><span class="line">... for size in sizes:</span><br><span class="line">... print((color, size))</span><br><span class="line">...</span><br><span class="line">(&#x27;black&#x27;, &#x27;S&#x27;)</span><br><span class="line">(&#x27;black&#x27;, &#x27;M&#x27;)</span><br><span class="line">(&#x27;black&#x27;, &#x27;L&#x27;)</span><br><span class="line">(&#x27;white&#x27;, &#x27;S&#x27;)</span><br><span class="line">(&#x27;white&#x27;, &#x27;M&#x27;)</span><br><span class="line">(&#x27;white&#x27;, &#x27;L&#x27;)</span><br><span class="line"></span><br><span class="line"># 想依照先尺码后颜色的顺序来排列，只需要调整从句的顺序</span><br><span class="line">&gt;&gt;&gt; tshirts = [(color, size) for size in sizes </span><br><span class="line">... for color in colors]</span><br><span class="line">&gt;&gt;&gt; tshirts</span><br><span class="line">[(&#x27;black&#x27;, &#x27;S&#x27;), (&#x27;white&#x27;, &#x27;S&#x27;), (&#x27;black&#x27;, &#x27;M&#x27;), (&#x27;white&#x27;, &#x27;M&#x27;),</span><br><span class="line"> (&#x27;black&#x27;, &#x27;L&#x27;), (&#x27;white&#x27;, &#x27;L&#x27;)]</span><br></pre></td></tr></table></figure>

<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>虽然也可以用列表推导来初始化元组、数组或其他序列类型，但是生成器表达式是更好的选择。这是因为生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。前面那种方式显然能够节省内存。</p>
<p><strong>生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; symbols = &#x27;$¢£¥€¤&#x27;</span><br><span class="line">&gt;&gt;&gt; tuple(ord(symbol) for symbol in symbols) </span><br><span class="line">➊ 如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外再用括号把它</span><br><span class="line">围起来。</span><br><span class="line">(36, 162, 163, 165, 8364, 164)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import array</span><br><span class="line">&gt;&gt;&gt; array.array(&#x27;I&#x27;, (ord(symbol) for symbol in symbols)) </span><br><span class="line">➋array 的构造方法需要两个参数，因此括号是必需的。array 构造方法的第一个参数</span><br><span class="line">指定了数组中数字的存储方式。</span><br><span class="line">array(&#x27;I&#x27;, [36, 162, 163, 165, 8364, 164])</span><br></pre></td></tr></table></figure>

<h3 id="使用生成器表达式计算笛卡儿积"><a href="#使用生成器表达式计算笛卡儿积" class="headerlink" title="使用生成器表达式计算笛卡儿积"></a>使用生成器表达式计算笛卡儿积</h3><p>利用生成器表达式实现了一个笛卡儿积，用以打印出上文中我们提到过的 T恤衫的 2 种颜色和 3 种尺码的所有组合。与示例 2-4 不同的是，用到生成器表达式之后，内存里不会留下一个有 6 个组合的列表，因为<strong>生成器表达式会在每次 for 循环运行时才生成一个组合</strong>。如果要计算两个各有 1000 个元素的列表的笛卡儿积，生成器表达式就可以帮忙省掉运行 for 循环的开销，即一个含有 100 万个元素的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; colors = [&#x27;black&#x27;, &#x27;white&#x27;]</span><br><span class="line">&gt;&gt;&gt; sizes = [&#x27;S&#x27;, &#x27;M&#x27;, &#x27;L&#x27;]</span><br><span class="line">&gt;&gt;&gt; for tshirt in (&#x27;%s %s&#x27; % (c, s) for c in colors for s in sizes): </span><br><span class="line">➊ 生成器表达式逐个产出元素，从来不会一次性产出一个含有 6 个 T 恤样式的列表</span><br><span class="line">... print(tshirt)</span><br><span class="line">...</span><br><span class="line">black S</span><br><span class="line">black M</span><br><span class="line">black L</span><br><span class="line">white S</span><br><span class="line">white M</span><br><span class="line">white L</span><br></pre></td></tr></table></figure>

<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加个字段的位置。正是这个位置信息给数据赋予了意义。<br>如果只把元组理解为不可变的列表，那其他信息——它所含有的元素的总数和它们的位置——似乎就变得可有可无。但是如果把元组当作一些字段的集合，那么数量和位置信息就变得非常重要了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lax_coordinates = (33.9425, -118.408056) </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; city, year, pop, chg, area = (&#x27;Tokyo&#x27;, 2003, 32450, 0.66, 8014) </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; traveler_ids = [(&#x27;USA&#x27;, &#x27;31195855&#x27;), (&#x27;BRA&#x27;, &#x27;CE342567&#x27;), </span><br><span class="line">... (&#x27;ESP&#x27;, &#x27;XDA205856&#x27;)]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for passport in sorted(traveler_ids): </span><br><span class="line">... print(&#x27;%s/%s&#x27; % passport) </span><br><span class="line">...</span><br><span class="line">BRA/CE342567</span><br><span class="line">ESP/XDA205856</span><br><span class="line">USA/31195855</span><br><span class="line"></span><br><span class="line"># for 循环可以分别提取元组里的元素，也叫作拆包（unpacking）。因为元组中第二个元素对我们没有什么用，所以它赋值给“_”占位符。</span><br><span class="line">&gt;&gt;&gt; for country, _ in traveler_ids: </span><br><span class="line">... print(country)</span><br><span class="line">...</span><br><span class="line">USA</span><br><span class="line">BRA</span><br><span class="line">ESP</span><br></pre></td></tr></table></figure>

<h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>拆包让元组可以完美地被当作记录来使用，最好辨认的元组拆包形式就是平行赋值，也就是说把一个可迭代对象里的元素，一并赋值到由对应的变量组成的元组中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lax_coordinates = (33.9425, -118.408056)</span><br><span class="line">&gt;&gt;&gt; latitude, longitude = lax_coordinates # 元组拆包</span><br><span class="line">&gt;&gt;&gt; latitude</span><br><span class="line">33.9425</span><br><span class="line">&gt;&gt;&gt; longitude</span><br><span class="line">-118.408056</span><br><span class="line"></span><br><span class="line">## 不使用中间变量交换两个变量的值</span><br><span class="line">&gt;&gt;&gt; b, a = a, b</span><br><span class="line"></span><br><span class="line">## 以用 * 运算符把一个可迭代对象拆开作为函数的参数</span><br><span class="line">&gt;&gt;&gt; divmod(20, 8)</span><br><span class="line">(2, 4)</span><br><span class="line">&gt;&gt;&gt; t = (20, 8)</span><br><span class="line">&gt;&gt;&gt; divmod(*t)</span><br><span class="line">(2, 4)</span><br><span class="line">&gt;&gt;&gt; quotient, remainder = divmod(*t)</span><br><span class="line">&gt;&gt;&gt; quotient, remainder</span><br><span class="line">(2, 4)</span><br><span class="line"></span><br><span class="line">## 让一个函数可以用元组的形式返回多个值，然后调用函数的代码就能轻松地接受这些返回值。比如 os.path.split() 函数就会返回以路径和最后一个文件名组成的元组 (path, last_part):</span><br><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; _, filename = os.path.split(&#x27;/home/luciano/.ssh/idrsa.pub&#x27;)</span><br><span class="line">&gt;&gt;&gt; filename</span><br><span class="line">&#x27;idrsa.pub&#x27;</span><br><span class="line"></span><br><span class="line">## 元组拆包中使用 * 也可以帮助我们把注意力集中在元组的部分元素上。</span><br><span class="line">&gt;&gt;&gt; a, b, *rest = range(5)</span><br><span class="line">&gt;&gt;&gt; a, b, rest</span><br><span class="line">(0, 1, [2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; a, b, *rest = range(3)</span><br><span class="line">&gt;&gt;&gt; a, b, rest</span><br><span class="line">(0, 1, [2])</span><br><span class="line">&gt;&gt;&gt; a, b, *rest = range(2)</span><br><span class="line">&gt;&gt;&gt; a, b, rest</span><br><span class="line">(0, 1, [])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="嵌套元组拆包"><a href="#嵌套元组拆包" class="headerlink" title="嵌套元组拆包"></a>嵌套元组拆包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 每个元组内有 4 个元素，其中最后一个元素是一对坐标。</span><br><span class="line">metro_areas = [</span><br><span class="line"> (&#x27;Tokyo&#x27;,&#x27;JP&#x27;,36.933,(35.689722,139.691667)), </span><br><span class="line"> (&#x27;Delhi NCR&#x27;, &#x27;IN&#x27;, 21.935, (28.613889, 77.208889)),</span><br><span class="line"> (&#x27;Mexico City&#x27;, &#x27;MX&#x27;, 20.142, (19.433333, -99.133333)),</span><br><span class="line"> (&#x27;New York-Newark&#x27;, &#x27;US&#x27;, 20.104, (40.808611, -74.020386)),</span><br><span class="line"> (&#x27;Sao Paulo&#x27;, &#x27;BR&#x27;, 19.649, (-23.547778, -46.635833)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(&#x27;&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;&#x27;.format(&#x27;&#x27;, &#x27;lat.&#x27;, &#x27;long.&#x27;))</span><br><span class="line">fmt = &#x27;&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># 们把输入元组的最后一个元素拆包到由变量构成的元组里，这样就获取了坐标</span><br><span class="line">for name, cc, pop, (latitude, longitude) in metro_areas: </span><br><span class="line">    if longitude &lt;= 0: </span><br><span class="line">         print(fmt.format(name, latitude, longitude))</span><br></pre></td></tr></table></figure>

<p><img src="/media/17472871721018/17472915708876.jpg"></p>
<h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><p>collections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import namedtuple</span><br><span class="line"></span><br><span class="line"># 创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者</span><br><span class="line">可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串</span><br><span class="line">&gt;&gt;&gt; City = namedtuple(&#x27;City&#x27;, &#x27;name country population coordinates&#x27;) </span><br><span class="line"></span><br><span class="line"># 存放在对应字段里的数据要以一串参数的形式传入到构造函数中（注意，元组的构造</span><br><span class="line">函数却只接受单一的可迭代对象）。</span><br><span class="line">&gt;&gt;&gt; tokyo = City(&#x27;Tokyo&#x27;, &#x27;JP&#x27;, 36.933, (35.689722, 139.691667)) </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; tokyo</span><br><span class="line"></span><br><span class="line">City(name=&#x27;Tokyo&#x27;, country=&#x27;JP&#x27;, population=36.933, coordinates=(35.689722,139.691667))</span><br><span class="line"></span><br><span class="line"># 通过字段名或者位置来获取一个字段的信息。</span><br><span class="line">&gt;&gt;&gt; tokyo.population ➌</span><br><span class="line">36.933</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; tokyo.coordinates</span><br><span class="line">(35.689722, 139.691667)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; tokyo[1]</span><br><span class="line">&#x27;JP&#x27;</span><br></pre></td></tr></table></figure>

<p>除了从普通元组那里继承来的属性之外，具名元组还有一些自己专有的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># fields 属性是一个包含这个类所有字段名称的元组。</span><br><span class="line">&gt;&gt;&gt; City._fields </span><br><span class="line">(&#x27;name&#x27;, &#x27;country&#x27;, &#x27;population&#x27;, &#x27;coordinates&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; LatLong = namedtuple(&#x27;LatLong&#x27;, &#x27;lat long&#x27;)</span><br><span class="line">&gt;&gt;&gt; delhi_data = (&#x27;Delhi NCR&#x27;, &#x27;IN&#x27;, 21.935, LatLong(28.613889, 77.208889))</span><br><span class="line"></span><br><span class="line"># 用 _make() 通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟</span><br><span class="line">City(*delhi_data) 是一样的。</span><br><span class="line">&gt;&gt;&gt; delhi = City._make(delhi_data) ➋</span><br><span class="line"></span><br><span class="line">#  _asdict() 把具名元组以 collections.OrderedDict 的形式返回，我们可以利用它来把元组里的信息友好地呈现出来。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; delhi._asdict() </span><br><span class="line">OrderedDict([(&#x27;name&#x27;, &#x27;Delhi NCR&#x27;), (&#x27;country&#x27;, &#x27;IN&#x27;), (&#x27;population&#x27;,</span><br><span class="line">21.935), (&#x27;coordinates&#x27;, LatLong(lat=28.613889, long=77.208889))])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for key, value in delhi._asdict().items():</span><br><span class="line"> print(key + &#x27;:&#x27;, value)</span><br><span class="line">name: Delhi NCR</span><br><span class="line">country: IN</span><br><span class="line">population: 21.935</span><br><span class="line">coordinates: LatLong(lat=28.613889, long=77.208889)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="列表或元组的方法和属性"><a href="#列表或元组的方法和属性" class="headerlink" title="列表或元组的方法和属性"></a>列表或元组的方法和属性</h2><p><img src="/media/17472871721018/17472920144835.jpg"></p>
<p><img src="/media/17472871721018/17472920373141.jpg"></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>在 Python 里，像列表（list）、元组（tuple）和字符串（str）这类序列类型都支持切片操作</p>
<blockquote>
<p>在切片和区间操作里不包含区间范围的最后一个元素</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = [10, 20, 30, 40, 50, 60]</span><br><span class="line">&gt;&gt;&gt; l[:2] # 在下标2的地方分割</span><br><span class="line">[10, 20]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l[2:]</span><br><span class="line">[30, 40, 50, 60]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l[:3] # 在下标3的地方分割</span><br><span class="line">[10, 20, 30]</span><br><span class="line"></span><br><span class="line"> &gt;&gt;&gt; l[3:]</span><br><span class="line">[40, 50, 60]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对对象进行切片"><a href="#对对象进行切片" class="headerlink" title="对对象进行切片"></a>对对象进行切片</h3><p>可以用 s[a:b:c] 的形式对 s 在 a 和 b 之间以 c 为间隔取值。c 的值还可以为负，负值意味着反向取值。<br>a:b:c 这种用法只能作为索引或者下标用在 [] 中来返回一个切片对象：slice(a,b,c)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &#x27;bicycle&#x27;</span><br><span class="line">&gt;&gt;&gt; s[::3]</span><br><span class="line">&#x27;bye&#x27;</span><br><span class="line">&gt;&gt;&gt; s[::-1]</span><br><span class="line">&#x27;elcycib&#x27;</span><br><span class="line">&gt;&gt;&gt; s[::-2]</span><br><span class="line">&#x27;eccb&#x27;</span><br></pre></td></tr></table></figure>

<p>slice() 是 Python 内置函数，用于创建一个切片对象，表示在序列（如列表、字符串、元组等）上进行切片操作的范围。</p>
<pre><code>s = &#39;Hello, World!&#39;
print(s[0:5])  # 输出 &#39;Hello&#39; 
等价于 
sl = slice(0, 5)
print(s[sl])  # 输出 &#39;Hello&#39;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; invoice = &quot;&quot;&quot;</span><br><span class="line">... 0.....6................................40........52...55........</span><br><span class="line">... 1909 Pimoroni PiBrella $17.50 3 $52.50</span><br><span class="line">... 1489 6mm Tactile Switch x20 $4.95 2 $9.90</span><br><span class="line">... 1510 Panavise Jr. - PV-201 $28.00 1 $28.00</span><br><span class="line">... 1601 PiTFT Mini Kit 320x240 $34.95 1 $34.95</span><br><span class="line">... &quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; SKU = slice(0, 6)</span><br><span class="line">&gt;&gt;&gt; DESCRIPTION = slice(6, 40)</span><br><span class="line">&gt;&gt;&gt; UNIT_PRICE = slice(40, 52)</span><br><span class="line">&gt;&gt;&gt; QUANTITY = slice(52, 55)</span><br><span class="line">&gt;&gt;&gt; ITEM_TOTAL = slice(55, None)</span><br><span class="line">&gt;&gt;&gt; line_items = invoice.split(&#x27;\n&#x27;)[2:]</span><br><span class="line">&gt;&gt;&gt; for item in line_items:</span><br><span class="line">... print(item[UNIT_PRICE], item[DESCRIPTION])</span><br><span class="line">...</span><br><span class="line"> $17.50 Pimoroni PiBrella</span><br><span class="line"> $4.95 6mm Tactile Switch x20</span><br><span class="line"> $28.00 Panavise Jr. - PV-201</span><br><span class="line"> $34.95 PiTFT Mini Kit 320x240</span><br></pre></td></tr></table></figure>

<h3 id="多维切片和省略"><a href="#多维切片和省略" class="headerlink" title="多维切片和省略"></a>多维切片和省略</h3><p>[] 运算符里还可以使用以逗号分开的多个索引或者是切片，外部库 NumPy 里就用到了这个特性，二维的 numpy.ndarray 就可以用 a[i, j] 这种形式来获取，抑或是用 a[m:n,k:l] 的方式来得到二维切片。</p>
<p>要正确处理这种 [] 运算符的话，对象的特殊方法 <strong>getitem</strong> 和 <strong>setitem</strong> 需要以元组的形式来接收a[i, j] 中的索引。也就是说，如果要得到 a[i, j] 的值，Python 会调用a.<strong>getitem</strong>((i, j))。</p>
<p>f(a, …, z)，或 a[i:…]。在 NumPy中，… 用作多维数组切片的快捷方式。如果 x 是四维数组，那么 x[i, …] 就是 x[i,:, :, :] 的缩写。</p>
<h3 id="给切片赋值"><a href="#给切片赋值" class="headerlink" title="给切片赋值"></a>给切片赋值</h3><p>把切片放在赋值语句的左边，或把它作为 del 操作的对象，我们就可以对序列进行<br>嫁接、切除或就地修改操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = list(range(10))</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l[2:5] = [20, 30]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0, 1, 20, 30, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; del l[5:7]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0, 1, 20, 30, 5, 8, 9]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l[3::2] = [11, 22]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0, 1, 20, 11, 5, 22, 9]</span><br><span class="line"></span><br><span class="line">#如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单</span><br><span class="line">独一个值，也要把它转换成可迭代的序列</span><br><span class="line">&gt;&gt;&gt; l[2:5] = 100 </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l[2:5] = [100]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0, 1, 100, 22, 9]</span><br></pre></td></tr></table></figure>

<h2 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h2><p>序列是支持 + 和 * 操作的。通常 + 号两侧的序列由相同类型的数据<br>所构成，在拼接的过程中，两个被操作的序列都不会被修改，Python 会新建一个包含同样类型数据的序列来作为拼接的结果。</p>
<p><strong>+ 和 * 都遵循不修改原有的操作对象，而是构建一个全新的序列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; l * 5</span><br><span class="line">[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 5 * &#x27;abcd&#x27;</span><br><span class="line">&#x27;abcdabcdabcdabcdabcd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在 a * n 这个语句中，序列 a 里的元素是对其他可变对象的引用的话，<br>你就需要格外注意了。比如，你想用my_list &#x3D; [[]] * 3 来初始化一个由列表组成的列表，但是你得到的列表里包含的 3 个元素其实是 3 个引用，而且这 3 个引用指向的都是同一个列表。</p>
</blockquote>
<h3 id="建立由列表组成的列表"><a href="#建立由列表组成的列表" class="headerlink" title="建立由列表组成的列表"></a>建立由列表组成的列表</h3><p>一个包含 3 个列表的列表，嵌套的 3 个列表各自有 3 个元素来代表井字<br>游戏的一行方块<br><strong>列表推导</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; board = [[&#x27;_&#x27;] * 3 for i in range(3)] ➊</span><br><span class="line">&gt;&gt;&gt; board</span><br><span class="line">[[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;]]</span><br><span class="line">&gt;&gt;&gt; board[1][2] = &#x27;X&#x27; ➋</span><br><span class="line">&gt;&gt;&gt; board</span><br><span class="line">[[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;X&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;]]</span><br></pre></td></tr></table></figure>

<p><strong>使用 “*”</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; weird_board = [[&#x27;_&#x27;] * 3] * 3 </span><br><span class="line">&gt;&gt;&gt; weird_board</span><br><span class="line">[[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;]]</span><br><span class="line"></span><br><span class="line">## 因为[&#x27;_&#x27;] * 3是可变对象的应用 导致原对象变化</span><br><span class="line">&gt;&gt;&gt; weird_board[1][2] = &#x27;O&#x27; </span><br><span class="line">&gt;&gt;&gt; weird_board</span><br><span class="line">[[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;O&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;O&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;O&#x27;]]</span><br></pre></td></tr></table></figure>

<h2 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h2><p>增量赋值运算符 +&#x3D; 和 *&#x3D; 的表现取决于它们的第一个操作对象。<br>+&#x3D; 背后的特殊方法是  __ iadd __（用于“就地加法”）。但是如果一个类没有实现这个方法的话，Python 会退一步调用 __ add __ 。</p>
<blockquote>
<p> a +&#x3D; b<br>如果 a 实现了 <strong>iadd</strong> 方法，就会调用这个方法。同时对可变序列（例如list、bytearray 和 array.array）来说，a 会就地改动，就像调用了 a.extend(b)一样。但是如果 a 没有实现 <strong>iadd</strong> 的话，a +&#x3D; b 这个表达式的效果就变得跟 a &#x3D; a+ b 一样了：首先计算 a + b，得到一个新的对象，然后赋值给 a。也就是说，在这个表达式中，变量名会不会被关联到新的对象，完全取决于这个类型有没有实现 <strong>iadd</strong> 这个方法。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; id(l)</span><br><span class="line">4311953800 ➊</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l *= 2</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[1, 2, 3, 1, 2, 3]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; id(l)</span><br><span class="line">4311953800 ➋</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; id(t)</span><br><span class="line">4312681568 ➌</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t *= 2</span><br><span class="line">&gt;&gt;&gt; id(t)</span><br><span class="line">4301348296 ➍</span><br><span class="line"></span><br><span class="line">❶ 刚开始时列表的 ID。</span><br><span class="line">❷ 运用增量乘法后，列表的 ID 没变，新元素追加到列表上。</span><br><span class="line">❸ 元组最开始的 ID。</span><br><span class="line">❹ 运用增量乘法后，新的元组被创建。</span><br></pre></td></tr></table></figure>

<h2 id="list-sort方法和内置函数sorted"><a href="#list-sort方法和内置函数sorted" class="headerlink" title="list.sort方法和内置函数sorted"></a>list.sort方法和内置函数sorted</h2><p>list.sort 方法会就地排序列表，也就是说不会把原列表复制一份。<br>与 list.sort 相反的是内置函数 sorted，它会新建一个列表作为返回值。这个方法可以接受任何形式的可迭代对象作为参数，甚至包括不可变序列或生成器。而不管 sorted 接受的是怎样的参数，它最后都会返回一个列表。</p>
<p>不管是 list.sort 方法还是 sorted 函数，都有两个可选的关键字参数。<br><strong>reverse</strong><br>　　如果被设定为 True，被排序的序列里的元素会以降序输出（也就是说把最大值当作最小值来排序）。这个参数的默认值是 False。<br><strong>key</strong><br>　　一个只有一个参数的函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。比如说，在对一些字符串排序时，可以用key&#x3D;str.lower 来实现忽略大小写的排序，或者是用 key&#x3D;len 进行基于字符串长度的排序。这个参数的默认值是恒等函数（identity function），也就是默认用元素自己的值来排序。
　　</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fruits = [&#x27;grape&#x27;, &#x27;raspberry&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 新建了一个按照字母排序的字符串列表。</span><br><span class="line">&gt;&gt;&gt; sorted(fruits)</span><br><span class="line">&gt;&gt;&gt; [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;raspberry&#x27;] </span><br><span class="line">&gt;&gt;&gt; fruits</span><br><span class="line">[&#x27;grape&#x27;, &#x27;raspberry&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;] </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sorted(fruits, reverse=True) 按照字母降序排序。</span><br><span class="line">[&#x27;raspberry&#x27;, &#x27;grape&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;] </span><br><span class="line"></span><br><span class="line">新建一个按照长度排序的字符串列表。因为这个排序算法是稳定的，grape 和 apple 的长度都是 5，它们的相对位置跟在原来的列表里是一样的。</span><br><span class="line">&gt;&gt;&gt; sorted(fruits, key=len)</span><br><span class="line">[&#x27;grape&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;raspberry&#x27;] </span><br><span class="line"></span><br><span class="line">按照长度降序排序的结果。结果并不是上面那个结果的完全翻转，因为用到的排序算法是稳定的，也就是说在长度一样时，grape 和 apple 的相对位置不会改变。</span><br><span class="line">&gt;&gt;&gt; sorted(fruits, key=len, reverse=True)</span><br><span class="line">[&#x27;raspberry&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;apple&#x27;] </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; fruits</span><br><span class="line">[&#x27;grape&#x27;, &#x27;raspberry&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;] </span><br><span class="line"></span><br><span class="line">对原列表就地排序，返回值 None 会被控制台忽略。 此时 fruits 本身被排序。</span><br><span class="line">&gt;&gt;&gt; fruits.sort() </span><br><span class="line">&gt;&gt;&gt; fruits</span><br><span class="line">[&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;raspberry&#x27;] </span><br></pre></td></tr></table></figure>

<h2 id="用bisect来管理已排序的序列"><a href="#用bisect来管理已排序的序列" class="headerlink" title="用bisect来管理已排序的序列"></a>用bisect来管理已排序的序列</h2><p>bisect 模块包含两个主要函数，bisect 和 insort，两个函数都利用二分查找算法来在有序序列中查找或插入元素。</p>
<h3 id="用bisect来搜索"><a href="#用bisect来搜索" class="headerlink" title="用bisect来搜索"></a>用bisect来搜索</h3><p>bisect 模块包含两个主要函数，bisect 和 insort，两个函数都利用二分查找算法来在有序序列中查找或插入元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import bisect</span><br><span class="line">import sys</span><br><span class="line">HAYSTACK = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30]</span><br><span class="line">NEEDLES = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31]</span><br><span class="line">ROW_FMT = &#x27;&#123;0:2d&#125; @ &#123;1:2d&#125; &#123;2&#125;&#123;0:&lt;2d&#125;&#x27;</span><br><span class="line"></span><br><span class="line">def demo(bisect_fn):</span><br><span class="line">    for needle in reversed(NEEDLES):</span><br><span class="line">         # 用特定的 bisect 函数来计算元素应该出现的位置。</span><br><span class="line">         position = bisect_fn(HAYSTACK, needle) </span><br><span class="line">         # 利用该位置来算出需要几个分隔符号。</span><br><span class="line">         offset = position * &#x27; |&#x27; </span><br><span class="line">         print(ROW_FMT.format(needle, position, offset)) </span><br><span class="line">     </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    if sys.argv[-1] == &#x27;left&#x27;: </span><br><span class="line">        bisect_fn = bisect.bisect_left</span><br><span class="line">    else:</span><br><span class="line">        bisect_fn = bisect.bisect</span><br><span class="line">    print(&#x27;DEMO:&#x27;, bisect_fn.__name__) </span><br><span class="line">    print(&#x27;haystack -&gt;&#x27;, &#x27; &#x27;.join(&#x27;%2d&#x27; % n for n in HAYSTACK))</span><br><span class="line">    demo(bisect_fn)</span><br></pre></td></tr></table></figure>
<p><img src="/media/17472871721018/17473010830518.jpg"></p>
<p><strong>bisect 的表现可以从两个方面来使用。</strong></p>
<ol>
<li>可选参数——lo 和 hi——来缩小搜寻的范围。lo 的默认值是 0，hi的默认值是序列的长度，即 len() 作用于该序列的返回值。</li>
<li>其次，bisect 函数其实是 bisect_right 函数的别名，后者还有个姊妹函数叫<br>bisect_left。它们的区别在于，bisect_left 返回的插入位置是原序列中跟被插元<br>素相等的元素的位置，也就是新元素会被放置于它相等的元素的前面，bisect_right<br>返回的则是跟它相等的元素之后的位置。这个细微的差别可能对于整数序列来讲没什么用，但是对于那些值相等但是形式不同的数据类型来讲，结果就不一样了。比如说虽然1&#x3D;&#x3D; 1.0 的返回值是 True，1 和 1.0 其实是两个不同的元素。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#建立一个用数字作为索引的查询表格，比如说把分数和成绩 对应起来</span><br><span class="line">&gt;&gt;&gt; def grade(score, breakpoints=[60, 70, 80, 90], grades=&#x27;FDCBA&#x27;):</span><br><span class="line">... i = bisect.bisect(breakpoints, score)</span><br><span class="line">... return grades[i]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]</span><br><span class="line">[&#x27;F&#x27;, &#x27;A&#x27;, &#x27;C&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;A&#x27;, &#x27;A&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="用bisect-insort插入新元素"><a href="#用bisect-insort插入新元素" class="headerlink" title="用bisect.insort插入新元素"></a>用bisect.insort插入新元素</h3><p>insort(seq, item) 把变量 item 插入到序列 seq 中，并能保持 seq 的升序顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import bisect</span><br><span class="line">import random</span><br><span class="line">SIZE=7</span><br><span class="line">random.seed(1729)</span><br><span class="line">my_list = []</span><br><span class="line">for i in range(SIZE):</span><br><span class="line"> new_item = random.randrange(SIZE*2)</span><br><span class="line"> bisect.insort(my_list, new_item)</span><br><span class="line"> print(&#x27;%2d -&gt;&#x27; % new_item, my_list)</span><br></pre></td></tr></table></figure>
<p><img src="/media/17472871721018/17482299298715.jpg"></p>
<p>insort 跟 bisect 一样，有 lo 和 hi 两个可选参数用来控制查找的范围。它也有个变体<br>叫 insort_left，这个变体在背后用的是 bisect_left。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>需要一个只包含数字的列表，那么 array.array 比 list 更高效。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from array import array  引入 array 类型。</span><br><span class="line">&gt;&gt;&gt; from random import random</span><br><span class="line">&gt;&gt;&gt; floats = array(&#x27;d&#x27;, (random() for i in range(10**7))) 建立一个双精度浮点数组（类型码是 &#x27;d&#x27;）</span><br><span class="line">&gt;&gt;&gt; floats[-1] 查看数组的最后一个元素。</span><br><span class="line">0.07802343889111107</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; fp = open(&#x27;floats.bin&#x27;, &#x27;wb&#x27;)</span><br><span class="line">&gt;&gt;&gt; floats.tofile(fp) 把数组存入一个二进制文件里。</span><br><span class="line">&gt;&gt;&gt; fp.close()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; floats2 = array(&#x27;d&#x27;) 新建一个双精度浮点空数组。</span><br><span class="line">&gt;&gt;&gt; fp = open(&#x27;floats.bin&#x27;, &#x27;rb&#x27;)</span><br><span class="line">&gt;&gt;&gt; floats2.fromfile(fp, 10**7) 把 1000 万个浮点数从二进制文件里读取出来。</span><br><span class="line">&gt;&gt;&gt; fp.close()</span><br><span class="line">&gt;&gt;&gt; floats2[-1] 查看数组的最后一个元素。</span><br><span class="line">0.07802343889111107</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; floats2 == floats 检查两个数组的内容是不是完全一样。</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<h2 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h2><p><strong>memoryview 是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片</strong></p>
<blockquote>
<p>内存视图其实是泛化和去数学化的 NumPy 数组。它让你在不需要复制内容的前提<br>下，在数据结构之间共享内存。其中数据结构可以是任何形式，比如 PIL 图片、SQLite 数据库和 NumPy 的数组，等等。这个功能在处理大型数据集合的时候非常重要。</p>
</blockquote>
<p>memoryview.cast 的概念跟数组模块类似，能用不同的方式读写同一块内存数据，而且内容字节不会随意移动。</p>
<p>通过改变数组中的一个字节来更新数组里某个元素的值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; numbers = array.array(&#x27;h&#x27;, [-2, -1, 0, 1, 2])</span><br><span class="line">&gt;&gt;&gt; memv = memoryview(numbers) 5 个短整型有符号整数的数组（类型码是 &#x27;h&#x27;）</span><br><span class="line">&gt;&gt;&gt; len(memv)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; memv[0] memv 里的 5 个元素跟数组里的没有区别。</span><br><span class="line">-2</span><br><span class="line">&gt;&gt;&gt; memv_oct = memv.cast(&#x27;B&#x27;) 创建一个 memv_oct，这一次是把 memv 里的内容转换成 &#x27;B&#x27; 类型，也就是无符号字符。</span><br><span class="line">&gt;&gt;&gt; memv_oct.tolist() 以列表的形式查看 memv_oct 的内容。</span><br><span class="line">[254, 255, 255, 255, 0, 0, 1, 0, 2, 0]</span><br><span class="line">&gt;&gt;&gt; memv_oct[5] = 4 把位于位置 5 的字节赋值成 4。</span><br><span class="line">&gt;&gt;&gt; numbers</span><br><span class="line">array(&#x27;h&#x27;, [-2, -1, 1024, 1, 2]) 因为我们把占 2 个字节的整数的高位字节改成了 4，所以这个有符号整数的值就变成了 1024。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = array.array(&#x27;h&#x27;, [-2, -1, 0, 1, 2])：创建一个由有符号短整型（类型码 &#x27;h&#x27;）组成的数组，包含5个元素。</span><br><span class="line">memv = memoryview(numbers)：创建一个 memoryview 对象 memv，它引用了 numbers 数组的数据。memoryview 提供了一种访问原始字节数据的方式，而无需复制数据。</span><br><span class="line">len(memv)：返回 memv 中的元素数量，这里是 5，因为数组中有5个 short 类型的值。</span><br><span class="line">memv[0]：访问第一个元素，其值为 -2，与原数组一致。</span><br><span class="line">memv_oct = memv.cast(&#x27;B&#x27;)：将 memoryview 的类型转换为 &#x27;B&#x27;，即无符号字符（unsigned char）。这一步不会改变底层数据，只是改变了看待数据的方式。</span><br><span class="line">memv_oct.tolist()：将 memv_oct 转换为列表形式查看，输出 [254, 255, 255, 255, 0, 0, 1, 0, 2, 0]。这是因为每个 short 占两个字节，在小端序机器上，-2 表示为 0b11111110 11111111，即 254 和 255，依此类推。</span><br><span class="line">memv_oct[5] = 4：修改第6个字节的值为 4，由于 numbers 是以 short 类型存储的，因此这个操作会改变 numbers 中第3个元素的高位字节。</span><br><span class="line">numbers：此时数组变为 array(&#x27;h&#x27;, [-2, -1, 1024, 1, 2])，因为第3个 short 值的高位字节被改为 4，低位字节仍然是 0，所以该值变成 4 * 256 + 0 = 1024。</span><br></pre></td></tr></table></figure>

<h2 id="NumPy和SciPy"><a href="#NumPy和SciPy" class="headerlink" title="NumPy和SciPy"></a>NumPy和SciPy</h2><p>NumPy 实现了多维同质数组（homogeneous array）和矩阵，这些数据结构不但能处理数字，还能存放其他由用户定义的记录。通过 NumPy，用户能对这些数据结构里的元素进行高效的操作。</p>
<p>SciPy 是基于 NumPy 的另一个库，它提供了很多跟科学计算有关的算法，专为线性代数、数值积分和统计学而设计。SciPy 的高效和可靠性归功于其背后的 C 和 Fortran 代码，而这些跟计算有关的部分都源自于 Netlib 库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy </span><br><span class="line">&gt;&gt;&gt; a = numpy.arange(12) 新建一个 0~11 的整数的 numpy.ndarry，然后把它打印出来。</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#x27;numpy.ndarray&#x27;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a.shape 看看数组的维度，它是一个一维的、有 12 个元素的数组。</span><br><span class="line">(12,)</span><br><span class="line">&gt;&gt;&gt; a.shape = 3, 4 把数组变成二维的</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([[ 0, 1, 2, 3],</span><br><span class="line"> [ 4, 5, 6, 7],</span><br><span class="line"> [ 8, 9, 10, 11]])</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; a[2] 打印出第 2 行。</span><br><span class="line">array([ 8, 9, 10, 11])</span><br><span class="line">&gt;&gt;&gt; a[2, 1] 打印第 2 行第 1 列的元素。</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; a[:, 1] 把第 1 列打印出来。</span><br><span class="line">array([1, 5, 9])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a.transpose() 把行和列交换，就得到了一个新数组。</span><br><span class="line">array([[ 0, 4, 8],</span><br><span class="line"> [ 1, 5, 9],</span><br><span class="line"> [ 2, 6, 10],</span><br><span class="line"> [ 3, 7, 11]])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">&gt;&gt;&gt; floats = numpy.loadtxt(&#x27;floats-10M-lines.txt&#x27;) 从文本文件里读取 1000 万个浮点数。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; floats[-3:]   利用序列切片来读取其中的最后 3 个数。</span><br><span class="line">array([ 3016362.69195522, 535281.10514262, 4566560.44373946])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; floats *= .5 把数组里的每个数都乘以 0.5</span><br><span class="line">&gt;&gt;&gt; floats[-3:]</span><br><span class="line">array([ 1508181.34597761, 267640.55257131, 2283280.22186973])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from time import perf_counter as pc 导入精度和性能都比较高的计时器</span><br><span class="line">&gt;&gt;&gt; t0 = pc(); floats /= 3; pc() - t0 把每个元素都除以 3，可以看到处理 1000 万个浮点数所需的时间还不足 40 毫秒。</span><br><span class="line">0.03690556302899495</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; numpy.save(&#x27;floats-10M&#x27;, floats) 把数组存入后缀为 .npy 的二进制文件。</span><br><span class="line">&gt;&gt;&gt; floats2 = numpy.load(&#x27;floats-10M.npy&#x27;, &#x27;r+&#x27;) 将上面的数据导入到另外一个数组里，这次 load 方法利用了一种叫作内存映射的机制，它让我们在内存不足的情况下仍然可以对数组做切片。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; floats2 *= 6</span><br><span class="line">&gt;&gt;&gt; floats2[-3:] 把数组里每个数乘以 6 之后，再检视一下数组的最后 3 个数。</span><br><span class="line">memmap([3016362.69195522, 535281.10514262, 4566560.44373946])</span><br></pre></td></tr></table></figure>

<h2 id="双向队列和其他形式的队列"><a href="#双向队列和其他形式的队列" class="headerlink" title="双向队列和其他形式的队列"></a>双向队列和其他形式的队列</h2><p>collections.deque 类（双向队列）是一个<strong>线程安全</strong>、可以快速从两端添加或者删除元素的数据类型。而且如果想要有一种数据类型来存放“最近用到的几个元素”，deque 也是一个很好的选择。这是因为在新建一个双向队列的时候，你可以指定这个队列的大小，如果这个队列满员了，还可以从反向端删除过期的元素，然后在尾端添加新的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; dq = deque(range(10), maxlen=10) maxlen 是一个可选参数，代表这个队列可以容纳的元素的数量，而且一旦设定，这个</span><br><span class="line">属性就不能修改</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dq.rotate(3) 队列的旋转操作接受一个参数 n，当 n &gt; 0 时，队列的最右边的 n 个元素会被移动到队列的左边。当 n &lt; 0 时，最左边的 n 个元素会被移动到右边。</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dq.rotate(-4)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dq.appendleft(-1) 当试图对一个已满（len(d) == d.maxlen）的队列做尾部添加操作的时候，它头部</span><br><span class="line">的元素会被删除掉。注意在下一行里，元素 0 被删除了</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dq.extend([11, 22, 33]) 在尾部添加 3 个元素的操作会挤掉 -1、1 和 2。</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dq.extendleft([10, 20, 30, 40])  extendleft(iter) 方法会把迭代器里的元素逐个添加到双向队列的左边，因此迭代器里的元素会逆序出现在队列里。</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)</span><br></pre></td></tr></table></figure>

<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>　　提供了同步（线程安全）类 Queue、LifoQueue 和 PriorityQueue，不同的线程可以利用这些数据类型来交换信息。这三个类的构造方法都有一个可选参数 maxsize，它接收正整数作为输入值，用来限定队列的大小。但是在满员的时候，这些类不会扔掉旧的元素来腾出位置。相反，如果队列满了，它就会被锁住，直到另外的线程移除了某个元素而腾出了位置。这一特性让这些类很适合用来控制活跃线程的数量。
　　</p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>  这个包实现了自己的 Queue，它跟 queue.Queue 类似，是设计给进程间通信用的。同时还有一个专门的 multiprocessing.JoinableQueue 类型，可以让任务管理变得更方便。</p>
<h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h3><p>  Python 3.4 新提供的包，里面有 Queue、LifoQueue、PriorityQueue 和JoinableQueue，这些类受到 queue 和 multiprocessing 模块的影响，但是为异步编程里的任务管理提供了专门的便利。</p>
<h3 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h3><p>  跟上面三个模块不同的是，heapq 没有队列类，而是提供了 heappush 和 heappop方法，让用户可以把可变序列当作堆队列或者优先队列来使用。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>序列构成的数组</p><p><a href="https://zcct123.github.io/2025/05/26/python/基础/序列构成的数组/">https://zcct123.github.io/2025/05/26/python/基础/序列构成的数组/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>zcct</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-05-26</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-05-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/python%E5%9F%BA%E7%A1%80/">python基础</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/zfb.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wx.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/05/26/python/%E5%9F%BA%E7%A1%80/%E5%8F%8C%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88Dunder%20Methods%EF%BC%89%E3%80%81%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">双下方法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/09/01/redis/GeoHash/"><span class="level-item">GeoHash</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="zcct"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zcct</p><p class="is-size-6 is-block">zcct</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">66</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/zclvct" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://gitee.com/zclvct"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-26T04:00:00.000Z">2025-05-26</time></p><p class="title"><a href="/2025/05/26/python/%E5%9F%BA%E7%A1%80/%E5%8F%8C%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88Dunder%20Methods%EF%BC%89%E3%80%81%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/">双下方法</a></p><p class="categories"><a href="/categories/python/">python</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-26T04:00:00.000Z">2025-05-26</time></p><p class="title"><a href="/2025/05/26/python/%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/">序列构成的数组</a></p><p class="categories"><a href="/categories/python/">python</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/GeoHash/">GeoHash</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/HyperLogLog/">HyperLogLog</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/Scan%E6%8C%87%E4%BB%A4/">Scan指令</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">九月 2024</span></span><span class="level-end"><span class="level-item tag">63</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><li><a class="level is-mobile" href="/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/juc/"><span class="tag">juc</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jvm/"><span class="tag">jvm</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python%E5%9F%BA%E7%A1%80/"><span class="tag">python基础</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql%E4%BC%98%E5%8C%96/"><span class="tag">sql优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"><span class="tag">事务处理</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><span class="tag">内存模型</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span class="tag">垃圾回收</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%80%A7/"><span class="tag">架构安全性</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><span class="tag">类加载</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%8F%E6%98%8E%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F/"><span class="tag">透明多级分流系统</span><span class="tag">6</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="ZCCT" height="28"></a><p class="is-size-7"><span>&copy; 2025 zcct</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>